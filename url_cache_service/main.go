package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	pb "github.com/rscales/malware/url_cache_api"
)

type urlCacheServer struct {
	pb.UnimplementedURLCacheServer
	listening_port int
}

func (s *urlCacheServer) GetURLInfo(context context.Context, request *pb.URLInfoRequest) (*pb.URLInfoResponse, error) {
	url := request.GetUrl()
	log.Printf("received get URL info request for URL:%s\n", url)
	url_info := &pb.URLInfo{Url: url, Malware: false}
	response := &pb.URLInfoResponse{UrlInfo: url_info, Status: 0, ErrorMessage: ""}
	return response, nil
}

func (s *urlCacheServer) SetFlaggedMalware(context context.Context, request *pb.URLInfoRequest) (*pb.URLInfoResponse, error) {
	url := request.GetUrl()
	log.Printf("received set URL flagged malware request for URL:%s\n", url)
	url_info := &pb.URLInfo{Url: url, Malware: true}
	response := &pb.URLInfoResponse{UrlInfo: url_info, Status: 0, ErrorMessage: ""}
	return response, nil
}

func initializeService(port int) {
	lis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", port))
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	var opts []grpc.ServerOption
	grpcServer := grpc.NewServer(opts...)
	grpc.WithTransportCredentials(insecure.NewCredentials())
	pb.RegisterURLCacheServer(grpcServer, &urlCacheServer{listening_port: port})
	grpcServer.Serve(lis)
}

func main() {
	if len(os.Args) != 2 {
		fmt.Printf("usage:%s <listening port>\n", os.Args[0])
		os.Exit(1)
	}
	port, err := strconv.Atoi(os.Args[1])
	if err != nil {
		fmt.Printf("usage:%s <listening port>\n", os.Args[0])
		os.Exit(1)
	}
	log.Printf("Initializing Service: %s on listening port:%d\n", os.Args[0], port)
	initializeService(port)
}
