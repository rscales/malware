package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"sync"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	pb "github.com/rscales/malware/url_cache_api"
)

type urlCacheServer struct {
	pb.UnimplementedURLCacheServer
	listening_port int
}

type URLCache struct {
	mutex sync.Mutex
	urls  map[string]struct{}
}

var instance URLCache
var once sync.Once

func (s *urlCacheServer) GetURLInfo(context context.Context, request *pb.URLInfoRequest) (*pb.URLInfoResponse, error) {
	var response *pb.URLInfoResponse
	url := request.GetUrl()

	log.Printf("received get URL info request for URL:%s\n", url)

	urlCache := getURLCacheInstance()
	present, err := urlCache.checkForURL(url)
	if err != nil {
		url_info := &pb.URLInfo{Url: url, Malware: false}
		response = &pb.URLInfoResponse{UrlInfo: url_info, Status: 1, ErrorMessage: err.Error()}
	} else {
		url_info := &pb.URLInfo{Url: url, Malware: present}
		response = &pb.URLInfoResponse{UrlInfo: url_info, Status: 0, ErrorMessage: ""}
	}

	return response, nil
}

func (s *urlCacheServer) SetFlaggedMalware(context context.Context, request *pb.URLInfoRequest) (*pb.URLInfoResponse, error) {
	var response *pb.URLInfoResponse
	url := request.GetUrl()

	log.Printf("received set URL flagged malware request for URL:%s\n", url)

	urlCache := getURLCacheInstance()
	err := urlCache.addURL(url)
	if err != nil {
		url_info := &pb.URLInfo{Url: url, Malware: false}
		response = &pb.URLInfoResponse{UrlInfo: url_info, Status: 1, ErrorMessage: err.Error()}
	} else {
		url_info := &pb.URLInfo{Url: url, Malware: true}
		response = &pb.URLInfoResponse{UrlInfo: url_info, Status: 0, ErrorMessage: ""}
	}

	return response, nil
}

func (urlCache *URLCache) addURL(url string) error {
	urlCache.mutex.Lock()
	_, found := urlCache.urls[url]
	if !found {
		log.Printf("updating malware list with url:%s\n", url)
		urlCache.urls[url] = struct{}{}
	}
	urlCache.mutex.Unlock()
	return nil
}

func (urlCache *URLCache) checkForURL(url string) (bool, error) {
	log.Printf("checking malware list for url:%s\n", url)
	if _, found := urlCache.urls[url]; found {
		log.Printf("malware list contains url:%s\n", url)
		return true, nil
	}
	log.Printf("malware list does not contain url:%s\n", url)
	return false, nil
}

func getURLCacheInstance() URLCache {
	once.Do(func() {
		instance = URLCache{urls: make(map[string]struct{})}
	})
	return instance
}

func initializeService(port int) {
	lis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", port))
	if err != nil {
		log.Fatalf("failed to initialize listener error: %v", err)
	}

	var opts []grpc.ServerOption
	grpcServer := grpc.NewServer(opts...)
	grpc.WithTransportCredentials(insecure.NewCredentials())
	pb.RegisterURLCacheServer(grpcServer, &urlCacheServer{listening_port: port})
	grpcServer.Serve(lis)
}

func main() {
	if len(os.Args) != 2 {
		fmt.Printf("usage:%s <listening port>\n", os.Args[0])
		os.Exit(1)
	}
	port, err := strconv.Atoi(os.Args[1])
	if err != nil {
		fmt.Printf("usage:%s <listening port>\n", os.Args[0])
		os.Exit(1)
	}
	log.Printf("initializing %s on listening port:%d\n", os.Args[0], port)
	initializeService(port)
}
