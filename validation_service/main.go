package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"sync"

	"github.com/rscales/malware/url_cache"
)

const URL_ADD_V1_PATTERN = "/v1/urladd"
const URL_INFO_V1_PATTERN = "/v1/urlinfo"
const LISTENING_HOST_AND_PORT = ":8080"
const URL_KEYWORD = "url"

type URLInfo struct {
	URL     string `json:"url"`
	Malware bool   `json:"malware"`
	Success bool   `json:"success"`
	Error   string `json:"error"`
}

var instance url_cache.URLCache
var argument string
var once sync.Once

func createURLInfoJSON(url string, malware bool, success bool, error string) string {
	urlInfo := &URLInfo{URL: url, Malware: malware, Success: success, Error: error}
	responseJSON, err := json.Marshal(urlInfo)
	if err != nil {
		log.Println(err)
		return ""
	}
	return string(responseJSON)
}

func getURLCacheInstance() url_cache.URLCache {
	once.Do(func() {
		instance = url_cache.CreateInstance(argument)
	})
	return instance
}

func getURLInfo(writer http.ResponseWriter, req *http.Request) {
	var response string
	log.Printf("url info request URI:%s\n", req.RequestURI)

	url := req.URL.Query().Get(URL_KEYWORD)
	log.Printf("url info request for url:%s\n", url)

	writer.WriteHeader(http.StatusCreated)
	writer.Header().Set("Content-Type", "application/json")

	urlCache := getURLCacheInstance()
	isCached, err := urlCache.CheckForURL(url)
	if err != nil {
		response = createURLInfoJSON(url, false, false, err.Error())
	} else {
		response = createURLInfoJSON(url, isCached, true, "")
	}

	fmt.Fprintln(writer, string(response))
}

func setAddURL(writer http.ResponseWriter, req *http.Request) {
	log.Printf("set url request URI:%s\n", req.RequestURI)
	writer.WriteHeader(http.StatusCreated)
	writer.Header().Set("Content-Type", "application/json")

	err := req.ParseForm()
	if err != nil {
		fmt.Println(writer, "Failed to parse form")
		return
	}

	url := req.Form.Get(URL_KEYWORD)
	log.Printf("set url request for url:%s\n", url)

	urlCache := getURLCacheInstance()
	urlCache.AddURL(url)
	response := createURLInfoJSON(url, true, true, "")

	fmt.Fprintln(writer, response)
}

func initializeService(hostnames string) {
	argument = hostnames
	http.HandleFunc(URL_ADD_V1_PATTERN, setAddURL)
	http.HandleFunc(URL_INFO_V1_PATTERN, getURLInfo)
	log.Printf("listening on address:%s\n", LISTENING_HOST_AND_PORT)
	http.ListenAndServe(LISTENING_HOST_AND_PORT, nil)
}

func main() {
	argNumber := len(os.Args)
	log.Printf("initializing Service: %s\n", os.Args[0])

	if argNumber == 1 {
		initializeService("")
	} else if argNumber == 2 {
		initializeService(os.Args[1])
	} else {
		fmt.Printf("usage:%s <hostname1:port>,<hostname2:port>...<hostnameN:port>\n", os.Args[0])
		os.Exit(1)
	}
}
