package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"sync"
)

const URL_ADD_V1_PATTERN = "/v1/urladd"
const URL_INFO_V1_PATTERN = "/v1/urlinfo"
const LISTENING_HOST_AND_PORT = ":8080"
const URL_KEYWORD = "url"

var instance *URLCache
var once sync.Once

type URLCache struct {
	mutex sync.Mutex
	urls  map[string]struct{}
}

type URLInfo struct {
	URL     string `json:"url"`
	Malware bool   `json:"malware"`
	Success bool   `json:"success"`
	Error   string `json:"error"`
}

func createURLInfoJSON(url string, malware bool, success bool, error string) string {
	urlinfo := &URLInfo{URL: url, Malware: malware, Success: success, Error: error}
	responseJSON, err := json.Marshal(urlinfo)
	if err != nil {
		log.Println(err)
		return ""
	}
	return string(responseJSON)
}

func getURLInfo(writer http.ResponseWriter, req *http.Request) {
	log.Printf("url info request URI:%s\n", req.RequestURI)

	url := req.URL.Query().Get(URL_KEYWORD)
	log.Printf("url info request for url:%s\n", url)

	writer.WriteHeader(http.StatusCreated)
	writer.Header().Set("Content-Type", "application/json")

	urlCache := getURLCache()
	isCached := urlCache.checkForURL(url)
	response := createURLInfoJSON(url, isCached, true, "")

	fmt.Fprintln(writer, string(response))
}

func setAddURL(writer http.ResponseWriter, req *http.Request) {
	log.Printf("set url request URI:%s\n", req.RequestURI)
	writer.WriteHeader(http.StatusCreated)
	writer.Header().Set("Content-Type", "application/json")

	err := req.ParseForm()
	if err != nil {
		fmt.Println(writer, "Failed to parse form")
		return
	}

	url := req.Form.Get(URL_KEYWORD)
	log.Printf("set url request for url:%s\n", url)

	urlCache := getURLCache()
	urlCache.addURL(url)
	response := createURLInfoJSON(url, true, true, "")

	fmt.Fprintln(writer, response)
}

func initializeService() {
	http.HandleFunc(URL_ADD_V1_PATTERN, setAddURL)
	http.HandleFunc(URL_INFO_V1_PATTERN, getURLInfo)
	log.Printf("Listening on address:%s\n", LISTENING_HOST_AND_PORT)
	http.ListenAndServe(LISTENING_HOST_AND_PORT, nil)
}

func (urlCache *URLCache) addURL(url string) {
	urlCache.mutex.Lock()
	_, found := urlCache.urls[url]
	if !found {
		log.Printf("updating malware list with url:%s\n", url)
		urlCache.urls[url] = struct{}{}
	}
	urlCache.mutex.Unlock()
}

func (urlCache *URLCache) checkForURL(url string) bool {
	log.Printf("checking malware list for url:%s\n", url)
	if _, found := urlCache.urls[url]; found {
		log.Printf("malware list contains url:%s\n", url)
		return true
	}
	log.Printf("malware list does not contain url:%s\n", url)
	return false
}

func getURLCache() *URLCache {
	once.Do(func() {
		instance = &URLCache{urls: make(map[string]struct{})}
	})
	return instance
}

func main() {
	log.Printf("Initializing Service: %s\n", os.Args[0])
	initializeService()
}
