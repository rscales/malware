package url_cache

import (
	"context"
	"hash/crc32"
	"log"
	"strings"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	pb "github.com/rscales/malware/url_cache_api"
)

const TABLE_POLYNOMIAL uint32 = 0xD5828281

type Node struct {
	Number   int
	Hostname string
	Client   pb.URLCacheClient
}

type DistributedURLCache struct {
	NodeCount  int
	Nodes      []Node
	CRC32Table *crc32.Table
}

func CreateDistributedURLCache(hostnameList string) *DistributedURLCache {
	log.Printf("initializing distributed url cache with hostname list:%s\n", hostnameList)
	nodeHostnames := strings.Split(hostnameList, ",")
	nodeCount := len(nodeHostnames)
	url_cache := DistributedURLCache{NodeCount: nodeCount, Nodes: make([]Node, nodeCount), CRC32Table: crc32.MakeTable(TABLE_POLYNOMIAL)}

	for i, nodeHostname := range nodeHostnames {
		clientConnection := createClientConnection(nodeHostname)
		node := Node{Number: i, Hostname: nodeHostname, Client: clientConnection}
		url_cache.Nodes[i] = node
	}

	return &url_cache
}

func createClientConnection(hostname string) pb.URLCacheClient {
	var opts []grpc.DialOption
	opts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))
	conn, err := grpc.NewClient(hostname, opts...)
	if err != nil {
		log.Printf("failed to setup connection to:%s with error:%s\n", hostname, err.Error())
	}
	//defer conn.Close()
	client := pb.NewURLCacheClient(conn)
	return client
}

func (urlCache *DistributedURLCache) AddURL(url string) error {
	node := urlCache.getPrimaryNodeForURL(url)
	log.Printf("updating node:%d malware list with url:%s\n", node.Number, url)
	_, err := node.Client.SetFlaggedMalware(context.Background(), &pb.URLInfoRequest{Url: url})
	if err != nil {
		return err
	}
	return nil
}

func (urlCache *DistributedURLCache) CheckForURL(url string) (bool, error) {
	node := urlCache.getPrimaryNodeForURL(url)
	log.Printf("checking node:%d malware list for url:%s\n", node.Number, url)
	urlInfoResponse, err := node.Client.GetURLInfo(context.Background(), &pb.URLInfoRequest{Url: url})
	if err != nil {
		return false, err
	}
	return urlInfoResponse.UrlInfo.Malware, nil
}

func (urlCache *DistributedURLCache) getPrimaryNodeForURL(url string) *Node {
	if urlCache.NodeCount == 1 {
		return &urlCache.Nodes[0]
	}

	hash := crc32.Checksum([]byte(url), urlCache.CRC32Table)
	nodeNumber := hash % uint32(urlCache.NodeCount)

	return &urlCache.Nodes[nodeNumber]
}
